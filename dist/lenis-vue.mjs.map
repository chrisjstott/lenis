{"version":3,"sources":["../packages/vue/src/provider.ts","../packages/vue/src/use-lenis.ts"],"sourcesContent":["import Tempus from '@darkroom.engineering/tempus'\nimport Lenis, { type ScrollCallback } from 'lenis'\nimport type { HTMLAttributes, InjectionKey, Plugin, PropType } from 'vue'\nimport {\n  defineComponent,\n  getCurrentInstance,\n  h,\n  onBeforeUnmount,\n  onMounted,\n  provide,\n  reactive,\n  ref,\n  shallowRef,\n  watch,\n} from 'vue'\n\nexport const LenisSymbol: InjectionKey<null> = Symbol('LenisContext')\n\nexport const VueLenis = defineComponent({\n  name: 'VueLenis',\n  props: {\n    root: {\n      type: Boolean as PropType<boolean>,\n      default: false,\n    },\n    autoRaf: {\n      type: Boolean as PropType<boolean>,\n      default: true,\n    },\n    rafPriority: {\n      type: Number as PropType<number>,\n      default: 0,\n    },\n    options: {\n      type: Object as PropType<ConstructorParameters<typeof Lenis>[0]>,\n      default: () => ({}),\n    },\n    props: {\n      type: Object as PropType<HTMLAttributes>,\n      default: () => ({}),\n    },\n  },\n  setup(props, { slots }) {\n    const lenisRef = shallowRef<Lenis | null>(null)\n    const tempusCleanupRef = shallowRef<() => void>()\n    const wrapper = ref<HTMLDivElement>()\n    const content = ref<HTMLDivElement>()\n\n    onMounted(() => {\n      lenisRef.value = new Lenis({\n        ...props.options,\n        ...(!props.root\n          ? {\n              wrapper: wrapper.value,\n              content: content.value,\n            }\n          : {}),\n      })\n    })\n\n    onBeforeUnmount(() => {\n      lenisRef.value?.destroy()\n      lenisRef.value = null\n    })\n\n    // Sync options\n    watch(props, (props, oldProps) => {\n      const rootChanged = oldProps.root !== props.root\n      const optionsChanged =\n        JSON.stringify(oldProps.options) !== JSON.stringify(props.options)\n\n      if (rootChanged || optionsChanged) {\n        lenisRef.value?.destroy()\n        lenisRef.value = new Lenis({\n          ...props.options,\n          ...(!props.root\n            ? {\n                wrapper: wrapper.value,\n                content: content.value,\n              }\n            : {}),\n        })\n      }\n    })\n\n    // Sync autoRaf\n    watch([lenisRef, props], ([lenis, props], [oldLenis, oldProps]) => {\n      if ((props.autoRaf === oldProps.autoRaf && lenis === oldLenis) || !lenis)\n        return\n      tempusCleanupRef.value?.()\n      tempusCleanupRef.value = Tempus.add((time: number) => lenis?.raf(time))\n    })\n\n    const callbacks = reactive<\n      { callback: ScrollCallback; priority: number }[]\n    >([])\n\n    function addCallback(callback: ScrollCallback, priority: number) {\n      callbacks.push({ callback, priority })\n      callbacks.sort((a, b) => a.priority - b.priority)\n    }\n\n    function removeCallback(callback: ScrollCallback) {\n      callbacks.splice(\n        callbacks.findIndex((cb) => cb.callback === callback),\n        1\n      )\n    }\n\n    const onScroll: ScrollCallback = (data) => {\n      for (let i = 0; i < callbacks.length; i++) {\n        callbacks[i]?.callback(data)\n      }\n    }\n\n    watch(lenisRef, (lenis) => {\n      lenis?.off('scroll', onScroll)\n      lenis?.on('scroll', onScroll)\n    })\n\n    const context = reactive({\n      lenis: lenisRef.value,\n      addCallback,\n      removeCallback,\n    })\n\n    watch(lenisRef, (lenis) => {\n      context.lenis = lenis\n    })\n\n    if (props.root) {\n      // Provide a null value to not get the empty injection warning\n      provide(LenisSymbol, null)\n    } else {\n      provide(LenisSymbol, context as any)\n    }\n\n    // Sync global lenis instance\n    const app = getCurrentInstance()\n    watch(\n      () => context,\n      (context) => {\n        if (props.root) {\n          if (!app) throw new Error('No app found')\n          app.appContext.config.globalProperties.$lenisContext.lenis =\n            context.lenis\n          app.appContext.config.globalProperties.$lenisContext.addCallback =\n            context.addCallback\n          app.appContext.config.globalProperties.$lenisContext.removeCallback =\n            context.removeCallback\n        }\n      },\n      { deep: true }\n    )\n\n    return () => {\n      if (props.root) {\n        return slots.default?.()\n      } else {\n        const combinedClassName = ['lenis', props.props?.class]\n          .filter(Boolean)\n          .join(' ')\n        delete props.props?.class\n\n        return h('div', { class: combinedClassName, ref: wrapper, ...props }, [\n          h('div', { ref: content }, slots.default?.()),\n        ])\n      }\n    }\n  },\n})\n\nexport const vueLenisPlugin: Plugin = (app) => {\n  app.component('lenis', VueLenis)\n  // Setup a global provide to silence top level useLenis injection warning\n  app.provide(LenisSymbol, null)\n  app.config.globalProperties.$lenisContext = reactive({\n    lenis: null,\n    addCallback: () => {},\n    removeCallback: () => {},\n  })\n}\n","import type { ScrollCallback } from 'lenis'\nimport {\n  getCurrentInstance,\n  inject,\n  nextTick,\n  onBeforeUnmount,\n  toRefs,\n  watch,\n} from 'vue'\nimport { LenisSymbol } from './provider'\nimport type { LenisContextValue } from './types'\n\nexport function useLenis(callback?: ScrollCallback, priority = 0) {\n  const lenisInjection = inject(LenisSymbol)\n  const app = getCurrentInstance()\n\n  const context =\n    lenisInjection ||\n    (app?.appContext.config.globalProperties.$lenisContext as LenisContextValue)\n\n  const { lenis } = toRefs(context)\n\n  // Wait two ticks to make sure the lenis instance is mounted\n  nextTick(() => {\n    nextTick(() => {\n      if (!lenis.value) {\n        throw new Error(\n          'No lenis instance found, either mount a root lenis instance or wrap your component in a lenis provider'\n        )\n      }\n    })\n  })\n\n  watch(\n    () => context,\n    ({ lenis, addCallback, removeCallback }) => {\n      if (!lenis || !addCallback || !removeCallback || !callback) return\n      removeCallback?.(callback)\n\n      addCallback?.(callback, priority)\n      callback?.(lenis)\n    },\n    { deep: true }\n  )\n\n  onBeforeUnmount(() => {\n    if (!context.removeCallback || !callback) return\n    context.removeCallback(callback)\n  })\n\n  return lenis\n}\n"],"mappings":"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","names":["props","context","getCurrentInstance","onBeforeUnmount","watch","getCurrentInstance","watch","lenis","onBeforeUnmount"]}